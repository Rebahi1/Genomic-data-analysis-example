# -*- coding: utf-8 -*-
"""analysis_script.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UoOhabWGqA2RlqU1oM_-wGY4xWuYUYiC

# Genomic Integration Site Enrichment Analysis
---
**Dataset:** L1, HIV, MLV insertion sites and ChromHMM chromatin states (hg19)  
**Objective:** Analyze integration preferences of transposable elements and retroviruses in human chromatin  
**Author:** Nour REBAHI  
**Date:** September 2025  
---

## Task 1: Introduction and Objective

**Background:**  
Transposable elements (L1) and retroviruses (HIV, MLV) integrate into host genomes in potentially non-random patterns. Understanding their integration preferences provides insights into silencing mechanisms and mutagenic effects.

**Research Question:**  
Do L1 retrotransposons, HIV lentivirus, and MLV retrovirus exhibit preferential integration into specific functional chromatin regions?

**Approach:**  
- Genomic intersection analysis of insertion sites with ChromHMM states
- Statistical enrichment testing using hypergeometric distribution
- Publication-quality visualization of integration preferences

**Upload data:**
1. Click the folder icon in the left sidebar
2. Upload these 4 BED files to Colab:
   - `chromatin_states.bed` (ChromHMM 18-state model, HeLa-S3)
   - `l1_insertions.bed` (L1 retrotransposon insertions)
   - `hiv_insertions.bed` (HIV lentivirus insertions)
   - `mlv_insertions.bed` (MLV retrovirus insertions)
"""

#!/usr/bin/env python3
"""
Genomic integration enrichment pipeline (Colab version)

This script performs the following steps:
 1. Loads chromatin states and insertion site BED files (L1, HIV, MLV)
 2. Intersects insertions with chromatin states
 3. Computes enrichment/depletion per chromatin state using a hypergeometric test
 4. Applies multiple testing correction
 5. Generates visualizations: heatmap, barplot, and combined figure panel
 6. Saves intersections, enrichment results, QC summary, and figures

Outputs:
 - enrichment_results.csv
 - enrichment_heatmap.png
 - enrichment_barplot.png
 - figure_panel.png (heatmap + barplot)
 - intersections_L1.bed, intersections_HIV.bed, intersections_MLV.bed
 - qc_insertions_summary.csv
"""

# ---------------------------
# IMPORTS
# ---------------------------
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import hypergeom
from statsmodels.stats.multitest import multipletests

# ---------------------------
# USER-SPECIFIED FILE PATHS
# ---------------------------
# Input BED files: chromatin states and insertion sites
CHROM = "chromatin_states.bed"
L1    = "l1_insertions.bed"
HIV   = "hiv_insertions.bed"
MLV   = "mlv_insertions.bed"

# Output directory
OUTDIR = "results"
os.makedirs(OUTDIR, exist_ok=True)  # create directory if it doesn't exist

# ---------------------------
# FUNCTION: LOAD CHROMATIN STATES
# ---------------------------
def load_chromatin_states(path):
    """
    Load ChromHMM BED file and compute segment lengths.
    Expects BED with at least 4 columns: chr, start, end, state.
    Returns a DataFrame with columns: chr, start, end, state, length
    """
    df = pd.read_csv(path, sep='\t', header=None, comment='#', engine='python')
    if df.shape[1] < 4:
        raise ValueError('Chromatin states BED must have at least 4 columns: chr start end state')
    df = df.iloc[:, :4]
    df.columns = ['chr', 'start', 'end', 'state']
    df['start'] = df['start'].astype(int)
    df['end'] = df['end'].astype(int)
    df['length'] = df['end'] - df['start']  # segment length in base pairs
    df = df.sort_values(['chr','start']).reset_index(drop=True)
    return df

# ---------------------------
# FUNCTION: LOAD INSERTIONS
# ---------------------------
def load_insertions(path, element_name):
    """
    Load BED file with insertion coordinates.
    Computes midpoint of each insertion as genomic position.
    Adds a column with element name (L1, HIV, or MLV).
    """
    df = pd.read_csv(path, sep='\t', header=None, comment='#', engine='python')
    if df.shape[1] < 3:
        raise ValueError('Insertion BED must have at least 3 columns: chr start end')
    df = df.iloc[:, :3]
    df.columns = ['chr','start','end']
    df['start'] = df['start'].astype(int)
    df['end'] = df['end'].astype(int)
    df['midpoint'] = (df['start'] + df['end']) // 2  # insertion midpoint
    df['element'] = element_name
    df = df.sort_values(['chr','midpoint']).reset_index(drop=True)
    return df

# ---------------------------
# FUNCTION: INTERSECT INSERTIONS WITH CHROMATIN STATES
# ---------------------------
def intersect_midpoints_to_states(insertions_df, chromatin_df):
    """
    Assign each insertion to the chromatin state it falls into.
    Returns DataFrame with columns: chr, position, element, state
    """
    results = []
    # Split chromatin states by chromosome for faster lookup
    chrom_by_chr = {c: chromatin_df[chromatin_df['chr'] == c].reset_index(drop=True)
                    for c in chromatin_df['chr'].unique()}

    for chrom in insertions_df['chr'].unique():
        ins_chr = insertions_df[insertions_df['chr'] == chrom]
        if chrom not in chrom_by_chr:
            # If chromosome missing in chromatin data, mark state as 'Unknown'
            tmp = pd.DataFrame({
                'chr': ins_chr['chr'].values,
                'position': ins_chr['midpoint'].values,
                'element': ins_chr['element'].values,
                'state': ['Unknown'] * len(ins_chr)
            })
            results.append(tmp)
            continue

        chrom_df = chrom_by_chr[chrom]
        starts = chrom_df['start'].values
        ends = chrom_df['end'].values
        states = chrom_df['state'].values
        positions = ins_chr['midpoint'].values

        # Find which chromatin interval each insertion falls into
        left_idx = np.searchsorted(starts, positions, side='right') - 1
        valid = (left_idx >= 0) & (left_idx < len(starts)) & (positions >= starts[left_idx]) & (positions < ends[left_idx])
        assigned = np.array(['Unknown'] * len(positions), dtype=object)
        assigned[valid] = states[left_idx[valid]]

        tmp = pd.DataFrame({
            'chr': ins_chr['chr'].values,
            'position': positions,
            'element': ins_chr['element'].values,
            'state': assigned
        })
        results.append(tmp)

    if results:
        return pd.concat(results, ignore_index=True)
    else:
        return pd.DataFrame(columns=['chr','position','element','state'])

# ---------------------------
# FUNCTION: COMPUTE ENRICHMENT
# ---------------------------
def compute_enrichment(intersections_df, chromatin_df):
    """
    Compute enrichment/depletion of insertions per chromatin state.
    Returns DataFrame with fold enrichment, log2 fold, p-values, and significance.
    """
    state_sizes = chromatin_df.groupby('state')['length'].sum().sort_index()
    total_bg = int(state_sizes.sum())  # total base pairs in genome considered

    # Observed insertions per element per state
    obs = intersections_df.groupby(['element','state']).size().unstack(fill_value=0)
    rows = []

    for elt in obs.index:
        n = int(obs.loc[elt].sum())  # total insertions for this element
        for st in state_sizes.index:
            k = int(obs.loc[elt].get(st, 0))  # observed insertions in this state
            K = int(state_sizes.loc[st])      # state size in bp
            expected = (K / total_bg) * n if total_bg > 0 else np.nan  # expected insertions
            # Hypergeometric test for enrichment and depletion
            p_enrich = hypergeom.sf(k-1, total_bg, K, n) if k > 0 else 1.0
            p_deplete = hypergeom.cdf(k, total_bg, K, n)
            p_two = min(1.0, 2.0 * min(p_enrich, p_deplete))  # two-sided p-value
            fold = (k / expected) if expected > 0 else np.nan
            log2 = np.log2(fold) if (expected>0 and k>0) else np.nan
            rows.append({
                'element': elt,
                'state': st,
                'observed': k,
                'expected': expected,
                'fold_enrichment': fold,
                'log2_fold_enrichment': log2,
                'p_value': p_two,
                'state_size_bp': K,
                'genome_fraction': K/total_bg if total_bg>0 else np.nan,
                'total_insertions_mapped': n
            })

    res = pd.DataFrame(rows)
    # Correct for multiple testing
    if not res['p_value'].isnull().all():
        _, p_adj, _, _ = multipletests(res['p_value'].fillna(1.0), alpha=0.05, method='fdr_bh')
        res['p_adj'] = p_adj
    else:
        res['p_adj'] = np.nan
    # Assign significance symbols
    res['signif'] = pd.cut(res['p_adj'], bins=[-1e-12, 0.001, 0.01, 0.05, 1], labels=['***','**','*','ns'])
    return res

# ---------------------------
# FUNCTION: PLOT HEATMAP
# ---------------------------
def plot_heatmap(enrichment_df, out_png):
    """
    Generate heatmap of log2 fold enrichment per chromatin state and element.
    Annotates cells with significance symbols.
    """
    pivot = enrichment_df.pivot(index='state', columns='element', values='log2_fold_enrichment')
    sig = enrichment_df.pivot(index='state', columns='element', values='signif')
    # Order states by genome coverage
    state_order = enrichment_df.groupby('state')['state_size_bp'].first().sort_values(ascending=False).index
    pivot = pivot.reindex(state_order)
    sig = sig.reindex(state_order)
    fig, ax = plt.subplots(figsize=(6,10))
    sns.heatmap(pivot, cmap='RdBu_r', center=0, vmin=-3, vmax=3, annot=sig, fmt='',
                cbar_kws={'label':'log2(Fold Enrichment)'}, ax=ax)
    ax.set_ylabel('ChromHMM state')
    ax.set_xlabel('Element')
    plt.tight_layout()
    fig.savefig(out_png, dpi=300)
    plt.close(fig)

# ---------------------------
# FUNCTION: PLOT BARPLOT OF TOP STATES
# ---------------------------
def plot_barplot_top_states(enrichment_df, out_png, top_n=5):
    """
    For each element, select top_n enriched and top_n depleted states
    and plot as horizontal barplots (facet by element).
    """
    elems = enrichment_df['element'].unique()
    frames = []
    for e in elems:
        sub = enrichment_df[enrichment_df['element']==e].copy()
        sub = sub.dropna(subset=['log2_fold_enrichment'])
        top = sub.sort_values('log2_fold_enrichment', ascending=False).head(top_n)
        bot = sub.sort_values('log2_fold_enrichment', ascending=True).head(top_n)
        sel = pd.concat([top, bot])
        sel['element'] = e
        frames.append(sel)

    plotdf = pd.concat(frames, ignore_index=True)
    g = sns.catplot(data=plotdf, kind='bar', x='log2_fold_enrichment', y='state',
                    col='element', sharex=False, height=4, aspect=0.9)
    g.set_titles('{col_name}')
    # Add vertical line at 0 for reference
    for ax in g.axes.flat:
        ax.axvline(0, color='k', linewidth=0.5)
    plt.tight_layout()
    g.savefig(out_png, dpi=300)
    plt.close()

# ---------------------------
# FUNCTION: CREATE FIGURE PANEL
# ---------------------------
def create_figure_panel(heatmap_png, barplot_png, out_png):
    """
    Combine heatmap and barplot PNGs vertically into a single panel image.
    """
    from PIL import Image
    h = Image.open(heatmap_png)
    b = Image.open(barplot_png)
    maxw = max(h.width, b.width)
    new_h = Image.new('RGB', (maxw, h.height + b.height), (255,255,255))
    new_h.paste(h, (0,0))
    new_h.paste(b, (0,h.height))
    new_h.save(out_png)

# ---------------------------
# FUNCTION: WRITE INTERSECTIONS TO BED
# ---------------------------
def write_intersections_bed(intersections_df, outpath):
    """
    Write per-element BED files with the state as the 4th column.
    Midpoint is converted to 1-bp interval.
    """
    for elt in intersections_df['element'].unique():
        subset = intersections_df[intersections_df['element']==elt].copy()
        subset['start'] = subset['position']
        subset['end'] = subset['position'] + 1
        out_fname = os.path.join(outpath, f'intersections_{elt}.bed')
        subset[['chr','start','end','state']].to_csv(out_fname, sep='\t', header=False, index=False)

# ---------------------------
# FUNCTION: WRITE QC SUMMARY
# ---------------------------
def write_qc_summary(insertions_list, intersections_df, out_csv):
    """
    Compute basic QC summary: total insertions, mapped, unmapped, fraction mapped.
    """
    rows = []
    for name, df in insertions_list:
        total = len(df)
        mapped = intersections_df[intersections_df['element']==name]
        mapped_count = mapped[mapped['state']!='Unknown'].shape[0]
        unknown_count = mapped[mapped['state']=='Unknown'].shape[0]
        rows.append({'element': name, 'total_insertions': total,
                     'mapped_to_states': mapped_count,
                     'unknown': unknown_count,
                     'mapped_fraction': mapped_count/total if total>0 else 0.0})
    pd.DataFrame(rows).to_csv(out_csv, index=False)

# ---------------------------
# MAIN EXECUTION
# ---------------------------
chrom = load_chromatin_states(CHROM)       # Load chromatin states
l1 = load_insertions(L1, 'L1')            # Load L1 insertions
hiv = load_insertions(HIV, 'HIV')         # Load HIV insertions
mlv = load_insertions(MLV, 'MLV')         # Load MLV insertions

# Combine all insertions
all_ins = pd.concat([l1, hiv, mlv], ignore_index=True)

# Intersect insertions with chromatin states
intersections = intersect_midpoints_to_states(all_ins, chrom)

# Write intersection BED files
write_intersections_bed(intersections, OUTDIR)

# Compute enrichment/depletion
enrichment = compute_enrichment(intersections, chrom)
enrichment.to_csv(os.path.join(OUTDIR, 'enrichment_results.csv'), index=False)

# Write QC summary
write_qc_summary([('L1', l1), ('HIV', hiv), ('MLV', mlv)], intersections,
                 os.path.join(OUTDIR, 'qc_insertions_summary.csv'))

# Generate plots
heatmap_png = os.path.join(OUTDIR, 'enrichment_heatmap.png')
barplot_png = os.path.join(OUTDIR, 'enrichment_barplot.png')
panel_png = os.path.join(OUTDIR, 'figure_panel.png')

plot_heatmap(enrichment, heatmap_png)
plot_barplot_top_states(enrichment, barplot_png, top_n=5)

# Combine into a single figure panel (heatmap + barplot)
try:
    create_figure_panel(heatmap_png, barplot_png, panel_png)
except Exception:
    # fallback if PIL not installed: copy heatmap as panel
    import shutil
    shutil.copy(heatmap_png, panel_png)

print("Files saved in:", OUTDIR)